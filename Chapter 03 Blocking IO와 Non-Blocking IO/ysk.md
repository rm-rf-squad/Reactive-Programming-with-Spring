# Chapter 03 Blocking I/O와 Non-Blocking I/O


## BlockingI/O

I/O는 프로그램이 외부의 입출력 장치들과 데이터를 주고받는것을 의미한다.

* DB I/O,네트워크 I/O 

프로그램 코드가 실행되면 스레드가 해당 코드를 실행하는데, 외부 I/O 요청을 보냈을떄 쓰레드가 일을 하지 못하고 멈춰 있다가,

응답이 돌아오면 그제서야 일을 하는것을 Blocking I/O라고 한다.

이 단점을 보완하기 위해 멀티 스레드를 매우 많이 만들어서 사용한다.

* 해당 애플리케이션 스레드가 블락당한거지, 다른 스레드들은 일할 수 있다. 운영체제의 스레드가 다른 애플리케이션 스레드를 실행시킬 수 있기 때문이다.

그러나 이런 방식은 컨텍스트 스위칭으로 인해 스레드 전환 비용이 발생한다.

* 기존에 실행되고 있던 스레드의 정보들을 PCB에 저장하고, 실행시켜야 할 프로세스 정보를 PCB에서 읽어오는 것을 컨텍스트 스위칭이라고 한다. 매우 비싸다
  * 왜?
  * 컨텍스트 스위칭 하는 동안에 CPU는 일을 하지 못하고 스위칭 해야하기 때문에 그만큼 놀게된다. 
  * 컨텍스트스위칭이 발생하면 CPU 캐시에있는 데이터가 새로운 프로세스의 데이터로 바뀌므로 히트도 낮아지고 메모리 접근도 해야하니 느려진다.
  * 페이지 테이블도 전환해야 한다. 새로운 프로세스의 페이지를 가리켜야 하기 때문이다. 
  * PCB, TCB등 접근하고 업데이트해야하므로 비싸다

또한 자바에서의 멀티스레드는 메모리를 많이 사용한다

* 일반적으로 한 스레드당 윈도우가 1MB, 리눅스/유닉스가 2MB 정도 사용됌. 그래서 최소 스프링 뜨면 몇백메가를 잡아먹는다
* 버츄얼 스레드로도 완벽히 해결은 못함. 버츄얼 스레드를 실행시키는 캐리어 스레드가 기존 플랫폼 스레드와 스펙이 비슷함

이러한 이유로 블로킹 I/O와 멀티스레드는 완벽한 대안은 아니다

## NonBlocking I/O

NonBlocking I/O의 경우,  요청한 스레드는 차단되지 않는다.

I/O 작업의 응답을 기다리지 않고 스레드가 다른 일을 하기 때문이다. 

때문에 하나의 스레드로 많은 요청 등을 처리할 수 있다.

그러나 다음과 같은 작업에는 NonBlocking I/O도 좋지 않다

* CPU Bound 작업. 결국 스레드가 CPU를 태우는것에 집중해야 하기 떄문에 다른 요청을 처리하지 못한다
* 전체 과정에 Blocking I/O가 단 1개라도 있는 경우 NonBlocking이 의미가 없다.
  * 왜? 아니 스레드가 Block됐는데 다른 NonBlocking일을 어떻게 합니까..
  * 그래서 JPA, MyBatis와 WebFlux는 맞지 않다.  (JDBC는 기본적으로 Blocking임)

## 함수 관점에서의 동기와 비동기의 차이 
Caller와 callee

함수가 다른 함수를 호출하는 상황에서

* Caller : 호출 하는 함수
* Callee: 호출 당하는 함수 

함수형 인터페이스는 호출한 쓰레드에서 실행된다. 

* 비동기에서 콜백으로 다룰 수 있다

A 모델과 B모델 두 모델의 차이를 잘 생각해보자

<img src="./images/image-20231008234726810.png">

* 왼쪽 모델에서의 main은 caller이며 callee를 호출하고 결과를 반환받고 나서 실행한다.
  * 즉 caller는 callee의 결과에 관심이 있으며 결과를 이용해서 다음 처리를 한다
* 반면 오른쪽 모델은 실행은 callee가 하며, 결과값만 반환받는다 
  * 즉 caller는 callee의 결과에 관심이 없으며 callee가 결과를 이용해서 callback을 수행한다  


동기는 

- 요청과 결과가 순차적으로 이루어지며  한 작업이 완료될 때까지 다음 작업이 기다린다
- 예를 들면, 함수를 호출하고 결과가 반환될 때까지 프로그램이 기다려야 하는 경우에 해당한다

비동기는

- 요청을 보낸 후 바로 결과를 기다리지 않습니다.
- 결과는 나중에 (콜백, 프로미스, 이벤트 등의 형태로) 처리될 수 있습니다.
- 예를 들면, 웹 요청을 보내고 결과를 기다리지 않고 다른 작업을 계속 수행한 후, 나중에 결과가 도착하면 처리하는 경우
## 함수 관점에서의 Blocking과 Nonblocking의 차이



Blocking: Caller가 Callee를 호출하고 callee가 완료되기 전까지 아무것도 할 수 없다

* 제어권을 Callee(호출 당하는 쪽 )가 갖고 있다
* Caller와 별도의 thread가 필요하지 않다 

NonBlokcing : Caller가 Callee를 호출한 후 결과를 받지 않아도 Caller는 본인의 일을 할 수 있다. 

* 제어권을 Caller(호출 하는 쪽)가 갖고 있다.
* Callee도 작업을 진행하므로 Caller와 다른 별도의 스레드가 필요하다.



그러나 동기와 블로킹은 다르다. 관심사가 다르다.

 "동기/비동기"는 결과를 누가 처리하는지 관한 것이며, "블로킹/논블로킹"은 작업을 호출한 후 제어권이 어떻게 처리되는지에 관한 것

* 동기 비동기의 관심사 : 결과, 결과 처리 주체 
* 블로킹 논블로킹의 관심사 : 제어권





1. **동기 (Synchronous) vs 비동기 (Asynchronous)**:
   - **관심사**: 결과의 "언제"
   - **동기**: 함수나 작업의 결과가 바로 반환되거나 완료될 때까지 기다린다. 결과가 준비될 때까지 다음 작업을 진행하지 않습니다.
   - **비동기**: 함수나 작업을 호출하면 그 결과를 즉시 기다리지 않습니다. 결과는 나중에, 특정 메커니즘(콜백, 프로미스, 이벤트 등)을 통해 알려줍니다.
2. **블로킹 (Blocking) vs 논블로킹 (Non-blocking)**:
   - **관심사**: 제어권의 "어떻게"
   - **블로킹**: 호출된 작업이 완료될 때까지 제어권을 유지합니다. 즉, 해당 작업이 끝날 때까지 현재 스레드나 프로세스는 다른 작업을 진행하지 않습니다.
   - **논블로킹**: 호출된 작업이 즉시 완료되지 않더라도 제어권을 즉시 반환합니다. 따라서 현재 스레드나 프로세스는 다른 작업을 계속 진행할 수 있습니다.

이해를 돕기 위한 추가적인 설명:

- **동기 블로킹**: 전통적인 함수 호출 방식. 함수 호출 후 반환값이나 결과를 받을 때까지 기다린다.
- **동기 논블로킹**: 이런 조합은 일반적이지 않다.
- **비동기 블로킹**: 가능한 조합이지만, 일반적인 비동기 패턴과는 다소 다르다.
- **비동기 논블로킹**: 이벤트 루프나 콜백을 사용하는 패턴. 함수 호출 후 결과를 기다리지 않고, 결과가 준비되면 나중에 콜백을 통해 처리한다.

|                  | 동기                                                         | 비동기                                                       |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Blocking**     | caller는 아무 것도 할 수 없는 상태가 된다. 결과를 얻은 후 직접 처리한다. | caller는 아무 것도 할 수 없는 상태가 된다. 결과는 callee가 처리한다. |
| **Non-blocking** | caller는 자기 할 일을 할 수 있다. 결과를 얻은 후 직접 처리한다. | caller는 자기 할 일을 할 수 있다. 결과는 callee가 처리한다.  |



## I/O 관점에서의 Blocking과 Nonblocking의 차이
blocking은 thread가 오랜 시간 일을 하거나 대기하는 경우 발생

> I/O는 CPU와 커널 사이에서 일어나는 일이다. 

- ﻿﻿CPU-bound blocking: 오랜 시간 일을 한다
- ﻿﻿IO-bound blocking: 오랜 시간 대기한다

### CPU-bound Blocking

- ﻿﻿thread가 대부분의 시간 CPU 점유
- ﻿﻿연산이 많은 경우
- ﻿﻿추가적인 코어를 투입
- ﻿﻿그래픽처리나 시뮬레이션 등 

### IO-bound blocking

- ﻿﻿thread가 대부분의 시간을 대기
- ﻿﻿파일 읽기/쓰기, network 요청 처리, 요청 전달 등에서 함수를 실행하고 있던 쓰레드가 sleep을 하게된다. 
- ﻿﻿IO-bound non-blocking 가능하다면 Caller(호출자)는 일을 할 수 있다.

### Blocking의 전파

- ﻿﻿하나의 함수에서 여러 함수를 호출하 기도 하고, 함수 호출은 중첩적으로 발생
- ﻿﻿callee는 caller가 되고 다시 다른 callee를 호출
- ﻿﻿blocking한 함수를 하나라도 호출한다면 caller는 blocking이 된다

- ﻿﻿함수가 non-blocking하려면 모든
- ﻿﻿함수가 non-blocking이어야 한다
- ﻿﻿따라서 I/O bound blocking 또한 발생하면 안된다

### I/O 모델의 공통점과 차이점

![image-20231009002006103](./images//image-20231009002006103.png)

공통점﻿﻿

- Applicationol Kernel의 결과에 관심이 있다.
- Application의 Kernel로부터 받은 결과를 이용해서 다음 작업을 수행한다
- caller는 callee의 결과에 관심이 있다 -> 동기

차이점

A 모델

- ﻿﻿Kernel이 응답을 돌려주기 전까지  Application은 아무것도 하지 않는다
- ﻿﻿caller는 callee가 완료될때까지 대기 -> Blocking

B 모델

* Kernel이 응답을 돌려주기 전에 Application은 다른 일을 수행한다

* caller는 callee를 기다리지 않고 본인의 일을 한다 -> Non-blocking

그래서 이모델은 동기 Blocking I/O 와 동기 NonBlokcing I/O 속한다. 

## Non-Blocking V/0 방식의 통신이 적합한 시스템

WebFlux가 무조건 좋다고 빠르다고 도입할 수는 없다.

왜그럴까? - 학습 난이도가 너무 높다. 리액티브라는 새로운 표준을 공부해야 한다. 

제대로 알지도 못하고 사용하면 결국 문제가 될 수 있다.

그럼 어떤것이 적합할까?

### 대량의 요청 트래픽이 발생하는 시스템

스케일아웃으로 해결하기 어려울 정도의트래픽을 받는경우 Webflux로 전환을 고려할만하다. 

서버 컴퓨팅 비용이 기하급수적으로 늘 수 있기 때문이다. webflux는 저비용으로 고수준을 이끌어낼 수 있다. 

### 마이크로서비스

마이크로서비스는 내부적으로 통신을 어마어마하게 많이하기 때문에 (I/O 발생) 블로킹 통신보다는 논블로킹 통신이 적합하다.

한 서비스가 블로킹으로 인해 지연된다면 다른서비스에도 영향을 미칠 수 있기 때문에다

### 스트리밍 또는 실시간 시스템

Webflux를 이용하면 무한 데이터 스트림을 만들기에 적합하기 떄문에 스트리밍 또는 실시간 시스템을 쉽게 구축할 수 있다. 

